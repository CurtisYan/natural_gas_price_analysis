# 信用评级量化需求文档

## 概述
Charlie希望让她的模型能够适用于未来的数据集，因此她需要一种通用的方法来生成分桶。给定与模型输入标签数量相对应的桶数，她希望找出最能概括数据的边界。您需要创建一个评级映射，将借款人的FICO评分映射到评级，其中较低的评级表示较好的信用评分。

这个过程被称为量化。您可以考虑通过优化结果桶的不同属性来解决这个问题，例如均方误差或对数似然（定义见下文）。有关量化的背景知识，请参见[这里](https://en.wikipedia.org/wiki/Quantization_(signal_processing))。

## 目标
开发一种量化方法，将FICO评分映射到信用评级，其中较低的评级代表较好的信用评分。

## 技术方法

### 均方误差（MSE）
您可以将此问题视为近似问题，尝试将桶中的所有条目映射到一个值，最小化相关的平方误差。我们现在要最小化以下内容：

$$
MSE = \frac{1}{n} \sum_{i=1}^{n} (Y_i - \hat{Y}_i)^2
$$
其中：
- $Y_i$ 是原始$FICO评分
- $\hat{Y}_i$ 是分配的桶值
- $n$ 是数据点的数量

### 对数似然
一种更复杂的可能性是最大化以下对数似然函数：

$$
LL(b_1, ..., b_{r-1}) = \sum_{i=1}^{r} [k_i \ln p_i + (n_i - k_i) \ln(1 - p_i)]
$$
其中：
- $b_i$ 是桶边界
- $n_i$ 是每个桶中的记录数
- $k_i$ 是每个桶中的违约数
- $p_i = k_i / n_i$ 是桶中的违约概率

该函数考虑了离散化的粗糙程度和每个桶中违约的密度。这个问题可以通过将其分解为子问题来解决，这些子问题可以逐步求解（即通过动态规划方法）。例如，您可以将问题分解为两个子问题，为FICO评分从0到600创建五个桶，为FICO评分从600到850创建五个桶。有关似然函数的更多背景信息，请参考此[页面](link)。此[页面](link)也可能对动态规划背景有所帮助。

## 需求

1. **输入**：
   - 来自贷款数据的FICO评分
   - 所需的桶数/评级数
   
2. **输出**：
   - 将FICO评分转换为评级的评级映射函数
   - 每个评级的桶边界
   - 较低的评级值应表示较好的信用评分

3. **约束条件**：
   - 该方法应可推广到未来的数据集
   - 评级系统应该是单调的（更高的FICO评分→更低的评级）
   - 桶边界应根据所选的优化标准达到最优

## 可交付成果

1. **量化函数**：一个接受以下参数的函数：
   - FICO评分数组
   - 桶数
   - 优化方法（MSE或对数似然）
   - 返回：桶边界和评级映射

2. **评级映射器**：一个函数，该函数：
   - 以FICO评分作为输入
   - 基于量化返回相应的评级

3. **评估指标**：
   - 量化的MSE
   - 对数似然值（如果使用该方法）
   - 数据点在各桶中的分布

4. **可视化**：
   - 显示FICO评分分布和桶边界的直方图
   - 每个桶/评级的违约率

## 使用示例

```python
# 示例函数签名
def quantize_fico_scores(fico_scores, num_buckets, method='mse'):
    """
    将FICO评分量化到桶中
    
    参数：
    - fico_scores: FICO评分数组
    - num_buckets: 所需的桶数
    - method: 'mse' 或 'log_likelihood'
    
    返回：
    - boundaries: 桶边界列表
    - rating_map: 将FICO评分映射到评级的函数
    """
    pass

# 使用方法
boundaries, rating_map = quantize_fico_scores(fico_data, 10, method='mse')
rating = rating_map(750)  # 返回FICO评分750的评级
```

## 技术考虑

1. **动态规划**：对于对数似然方法，考虑使用动态规划高效地找到最优桶边界。

2. **单调性**：确保评级系统保持正确的顺序（更高的FICO→更低的评级）。

3. **边缘情况**：处理边缘情况，例如：
   - 训练数据范围之外的FICO评分
   - 空桶
   - 极端分布

4. **可扩展性**：解决方案应该能够高效地处理大型数据集。
